module len;

import l;

//mixin template 
//Len (T) {
//    From from;
//    To   to;

//    struct
//    From {
//        LC lc;
//    }

//    struct
//    To {
//        import l : L;
//        L[2] s;
//    }
//}


struct
LC {
    L length;
    const L capacity = 0xFFFF;  // a * length >> 16
}

void 
test_lc () {
    auto x = 1/1024;
    auto screen_w = 1366;

    auto screen_x = x * 1366 / 1024;
    //1024   = 1366;
    //x/1024 = sx/1366;
}

void 
test_lc_2 () {
    auto x = 1/65536;
    auto screen_w = 1366;

    auto screen_x = x * 1366 / 65536;  // range x
                                        // if screen_w > 65536 then line
                                        // if screen_w < 65536 then dot
                                        // if screen_w = 65536 then dot
    //0xFFFF   = 1366;
    //x/0xFFFF = sx/1366;
    enum capacity = 65536;  // 2^^16
    enum capacity_pow = 16;
    auto screen_x_ = x * screen_w / capacity;
    auto screen_x__ = x * screen_w / 2^^16;
    auto screen_x___ = x * screen_w >> 16;
    auto screen_x____ = x * screen_w >> capacity_pow;   // imul EAX, EСX
                                                        // shr  EAX, 16

    // x86 float
    //   32 bit
    // 1    1111_1111 0 00_0000_0000_0000_0000_0000
    // sign pow       . .

    // Fixed float
    // .    ...._.... . .._.... ...._...._...._....
    // 1    1111_1111 0 00_0000_0000_0000_0000_0000

    // Fixed float
    // ...._...._...._.... ...._...._...._....
    // ^^^^_^^^^_^^^^_^^^^ s000_0000_0000_0000

    // Детализация числа больше детализации экрана
    // 65536                    1366

    // Fixed float 16
    // ...._...._...._....
    // s000_0000_0000_0000

    // Fixed float 32
    // ...._...._...._.... ...._...._...._....
    // s000_0000_0000_0000 0000_0000_0000_0000
    // value               хвост

    auto screen_x_____ = x * screen_w >> capacity_pow;   
    // mov  EAX, x
    // mov  ECX, screen_x
    //
    // imul EAX, EСX
    // shr  EAX, 16   // xchg AXL, AXH
    //
    // mov  result, AX

    // cccc_cccc_cccc_cccc = aaaa_aaaa * bbbb_bbbb / 2^^16
    // 1111_1111_0000_0000
    // взять лувую часть 
    // 1111_1111

    // 65536 / 1366 единиц в пикселе = 47,977
    // 65536 / 1024 единиц в пикселе = 64

    // Все вычисления в 1/65536
    // 0 ............................ 2^^16 = 65536
    //
    // Вывод на экран
    // 0 ............................ 1024
    // x = a / 2^^16 * 1024
    // x = a / 2^^16 * 2^10
    // x = a >> 16 << 10
    // x = a >> 6
    //
    // Всегда на уменьшение.
    // Всегда от большей детализации к меньшей
    // Всегда кратно 2
    //   оставшиеся пиксели - слева и справа - картинка по центру
    //   никакого upscaling
    // 1024
    // 1366 = 1024 + 342 = 171 слева + 1024 + справа 171
    //
    // Начинается с 0
    // + x_offset для обеспечения сдвига за границу экрана влево
    // (все числа целые, 0..65536, знака нет, все операции беззнаковые, целые)
    //
    // Просто сдвиг вправо на 6 бит
    // Просто сдвиг вправо на N бит
    //   на x86 80486 cдвиг стал занимать всего 3 такта, что было быстрее, чем умножение, которое занимало около 26 тактов.
}

